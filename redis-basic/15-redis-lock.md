# redis 分布式锁

## 分布式锁

在分布式系统中，当不同进程或线程一起访问共享资源时，会造成资源争抢，如果不加以控制的话，就会引发程序错乱。分布式锁能够非常有效的解决这个问题，它采用了一种互斥机制来防止线程或进程间相互干扰，从而保证了数据的一致性。

## 分布式锁的特点

- 互斥性, 同一时刻只能一个线程持有锁
- 可重入性, 同一节点上的同一线程如果获取锁之后, 能够再次获取锁
- 锁超时, 一个线程持有锁的时间一定时长后, 能够自动释放锁, 从而防止死锁
- 高性能、高可用, 加锁解锁要高效, 同时保证高可用, 防止分布式锁失效
- 具备阻塞、非阻塞性, 能够即使从阻塞状态中被唤醒

## redis 实现分布式锁的特点

- 互斥性, 在任意时刻，只有一个线程能够持有锁;
- 可重入性, 加锁和解锁必须是由同一个线程来设置, 可以通过代码实现重入效果;
- 锁超时, redis通过给key设置超时时间, 来保证该线程在超时后可以释放锁;
- 高性能、高可用, redis 拥有很高的性能，因此加锁和释放锁开销较小，并且能够很轻易地实现分布式锁, redis集群部署可以实现高可用;

## redis 实现方案
1. 使用命令 `setnx key val` `expire key timeout`(两个命令不是原子性操作, 可能会存在死锁的场景)
2. 使用 lua 脚本, 包含setnx、exprie两条命令，脚本保证了两条命令的原子性
3. 使用命令 `set key val [expiration EX seconds|PX millisenconds] [NX|XX]` (redis 2.6.12 版本开始支持) (单节点中正确使用方式，但是实际上在Redis集群的时候, 此方案也会出现问题，比如说A客户端在Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点，master故障，发生故障转移，一个slave节点升级为master节点，B客户端也可以获取同个key的锁，但客户端A也已经拿到锁了，这就导致多个客户端都拿到锁。)
```text
// 伪代码
// 1.获取锁, 需要保证value的唯一性(可以是UUID)
set resource_lock_key unique_val nx px 30000
// 2.持有锁, 进行业务操作

// 3.释放锁, 在 lua 脚本中一定要比较 value, 防止误解锁(只解锁属于自己的锁)
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```
4. Redlock 算法与 Redission 实现

## redlock 算法

### 基础概念

- TTL time to live 指的 redis key 的过期时间
- clock drift 时钟漂移, 指两个电脑间时间流速基本相同的情况下，两个电脑（或两个进程间）时间的差值；如果电脑距离过远会造成时钟漂移值 过大

### 最低保证分布式锁的有效性及安全性的要求

- 互斥性
- 释放死锁
- 容错性, 多数redis节点(一半以上)可用, 客户端可以获取释放锁

### 多节点 redis 实现分布式锁 redlock 算法: 有效防止单点故障

假设有 N个 Redis master 完全互相独立的节点，且不存在主从复制或者其他集群协调机制。 确保将在 N个 实例上使用与在Redis 单实例 下相同方法获取和释放锁。
假设有 5个 Redis master 节点，同时在 5台服务器 上面运行这些 Redis 实例，保证 5个 redis 节点不会同时都宕掉。

为了取到锁，客户端应该执行以下操作:

- 客户端获取本机当前Unix时间，以毫秒为单位(假设计为 T1 )。
- 客户端依次尝试从 5个 redis服务器实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间( response_timeout )，这个超时时间应该小于锁的失效时间 TTL 。例如你的锁自动失效时间 TTL 为 10s，则超时时间应该在 5-50 ms 毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。
- 客户端使用当前时间 T2 减去 (第一步)开始获取锁时间 T1 ，就得到获取锁所消耗的时间 (time spent)。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且获取锁所消耗的时间 (time spent) 小于锁失效时间 TTL 时，锁才算获取成功。
- 如果成功取到了锁，key的真正有效时间等于有效时间减去(第三步)获取锁所消耗的时间 (time spent), 再减去时钟漂移时长 (clock drift)
- 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。

#### redlock 失败重试

当client不能获取锁时，应该在随机时间后重试获取锁；并且最好在同一时刻并发的把set命令发送给所有redis实例；而且对于已经获取锁的client在完成任务后要及时释放锁，这是为了节省时间.

#### redlock 释放锁

由于释放锁时会判断这个锁的value是不是自己设置的，如果是才删除；所以在释放锁时非常简单，只要向所有实例都发出释放锁的命令，不用考虑能否成功释放锁。

#### redlock 注意点

1.先假设client获取所有实例，所有实例包含相同的key和过期时间(TTL) ,但每个实例set命令时间不同导致不能同时过期，第一个set命令之前是T1,最后一个set命令后为T2,则此client有效获取锁的最小时间为TTL-(T2-T1)-时钟漂移;

2.对于以N/2+ 1(也就是一半以 上)的方式判断获取锁成功，是因为如果小于一半判断为成功的话，有可能出现多个client都成功获取锁的情况， 从而使锁失效

3.一个client锁定大多数事例耗费的时间大于或接近锁的过期时间，就认为锁无效，并且解锁这个redis实例(不执行业务) ;只要在TTL时间内成功获取一半以上的锁便是有效锁;否则无效

#### redlock 性能考虑以及故障恢复解决方案

1.如果redis没有持久化功能，在clientA获取锁成功后，所有redis重启，clientB能够再次获取到锁，这样违法了锁的排他互斥性;

2.如果启动AOF永久化存储，事情会好些， 举例:当我们重启redis后，由于redis过期机制是按照unix时间戳走的，所以在重启后，然后会按照规定的时间过期，不影响业务;但是由于AOF同步到磁盘的方式默认是每秒-次，如果在一秒内断电，会导致数据丢失，立即重启会造成锁互斥性失效;但如果同步磁盘方式使用Always(每一个写命令都同步到硬盘)造成性能急剧下降;所以在锁完全有效性和性能方面要有所取舍;

3.有效解决既保证锁完全有效性及性能高效及即使断电情况的方法是redis同步到磁盘方式保持默认的每秒，在redis无论因为什么原因停掉后要等待TTL时间后再重启(学名:延迟重启) ;缺点是 在TTL时间内服务相当于暂停状态;

### redlock 总结

1.TTL时长 要大于正常业务执行的时间+获取所有redis服务消耗时间+时钟漂移

2.获取redis所有服务消耗时间要 远小于TTL时间，并且获取成功的锁个数要 在总数的一般以上:N/2+1

3.尝试获取每个redis实例锁时的时间要 远小于TTL时间

4.尝试获取所有锁失败后 重新尝试一定要有一定次数限制

5.在redis崩溃后（无论一个还是所有），要延迟TTL时间重启redis

6.在实现多redis节点时要结合单节点分布式锁算法 共同实现